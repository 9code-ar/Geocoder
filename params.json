{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Geocoder\r\n========\r\n\r\n**Geocoder** is a library which helps you build geo-aware applications. It provides an abstraction layer for geocoding manipulations.\r\nThe library is splitted in two parts: `HttpAdapter` and `Provider` and is really extensible.\r\n\r\n[![Build Status](https://secure.travis-ci.org/willdurand/Geocoder.png?branch=master)](http://travis-ci.org/willdurand/Geocoder)\r\n\r\n\r\n### HttpAdapters ###\r\n\r\n_HttpAdapters_ are responsible to get data from remote APIs.\r\n\r\nCurrently, there are the following adapters:\r\n\r\n* `BuzzHttpAdapter` to use [Buzz](https://github.com/kriswallsmith/Buzz), a lightweight PHP 5.3 library for issuing HTTP requests;\r\n* `CurlHttpAdapter` to use [cURL](http://php.net/manual/book.curl.php);\r\n* `GuzzleHttpAdapter` to use [Guzzle](https://github.com/guzzle/guzzle), PHP 5.3+ HTTP client and framework for building RESTful web service clients;\r\n* `SocketHttpAdapter` to use a [socket](http://www.php.net/manual/function.fsockopen.php);\r\n* `ZendHttpAdapter` to use [Zend Http Client](http://framework.zend.com/manual/2.0/en/modules/zend.http.client.html).\r\n\r\n\r\n### Providers ###\r\n\r\n_Providers_ contain the logic to extract useful information.\r\n\r\nCurrently, there are many providers for the following APIs:\r\n\r\n* [FreeGeoIp](http://freegeoip.net/static/index.html) as IP-Based geocoding provider;\r\n* [HostIp](http://www.hostip.info/) as IP-Based geocoding provider;\r\n* [IpInfoDB](http://www.ipinfodb.com/) as IP-Based geocoding provider;\r\n* [Yahoo! PlaceFinder](http://developer.yahoo.com/geo/placefinder/) as Address-Based geocoding and reverse geocoding provider;\r\n* [Google Maps](http://code.google.com/apis/maps/documentation/geocoding/) as Address-Based geocoding and reverse geocoding provider;\r\n* [Bing Maps](http://msdn.microsoft.com/en-us/library/ff701715.aspx) as Address-Based geocoding and reverse geocoding provider;\r\n* [OpenStreetMaps](http://nominatim.openstreetmap.org/) as Address-Based geocoding and reverse geocoding provider;\r\n* [CloudMade](http://developers.cloudmade.com/projects/show/geocoding-http-api) as Address-Based geocoding and reverse geocoding provider;\r\n* [Geoip](http://php.net/manual/book.geoip.php), the PHP extension, as IP-Based geocoding provider;\r\n* ChainProvider is a special provider that takes a list of providers and iterates\r\n  over this list to get information;\r\n* [MapQuest](http://open.mapquestapi.com/) as Address-Based geocoding and reverse geocoding provider;\r\n* [OIORest](http://geo.oiorest.dk/) as very accurate Address-Based geocoding provider (exclusively in Denmark);\r\n* [GeoCoder.ca](http://geocoder.ca/) as Address-Based geocoding and reverse geocoding provider (exclusively in USA & Canada);\r\n* [GeoCoder.us](http://geocoder.us/) as Address-Based geocoding provider (exclusively in USA);\r\n* [IGN OpenLS](http://www.ign.fr/) as Address-Based geocoding provider (exclusively in France);\r\n* [DataScienceToolkit](http://www.datasciencetoolkit.org/) as IP-Based geocoding provider.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nThe recommended way to install Geocoder is through composer.\r\n\r\nJust create a `composer.json` file for your project:\r\n\r\n``` json\r\n{\r\n    \"require\": {\r\n        \"willdurand/geocoder\": \"*\"\r\n    }\r\n}\r\n```\r\n\r\nAnd run these two commands to install it:\r\n\r\n``` bash\r\n$ wget http://getcomposer.org/composer.phar\r\n$ php composer.phar install\r\n```\r\n\r\nNow you can add the autoloader, and you will have access to the library:\r\n\r\n``` php\r\n<?php\r\n\r\nrequire 'vendor/autoload.php';\r\n```\r\n\r\nIf you don't use neither **Composer** nor a _ClassLoader_ in your application, just require the provided autoloader:\r\n\r\n``` php\r\n<?php\r\n\r\nrequire_once 'src/autoload.php';\r\n```\r\n\r\nYou're done.\r\n\r\n\r\nUsage\r\n-----\r\n\r\nFirst, you need an `adapter` to query an API:\r\n\r\n``` php\r\n<?php\r\n\r\n$adapter  = new \\Geocoder\\HttpAdapter\\BuzzHttpAdapter();\r\n```\r\n\r\nThe `BuzzHttpAdapter` is tweakable, actually you can pass a `Browser` object to this adapter:\r\n\r\n``` php\r\n<?php\r\n\r\n$buzz    = new \\Buzz\\Browser(new \\Buzz\\Client\\Curl());\r\n$adapter = new \\Geocoder\\HttpAdapter\\BuzzHttpAdapter($buzz);\r\n```\r\n\r\nNow, you have to choose a `provider` which is closed to what you want to get.\r\n\r\n\r\n### FreeGeoIpProvider ###\r\n\r\nThe `FreeGeoIpProvider` is able to geocode **IPv4 and IPv6 addresses** only.\r\n\r\n\r\n### HostIpProvider ###\r\n\r\nThe `HostIpProvider` is able to geocode **IPv4 addresses** only.\r\n\r\n\r\n### IpInfoDbProvider ###\r\n\r\nThe `IpInfoDbProvider` is able to geocode **IPv4 addresses** only.\r\n\r\n\r\n### YahooProvider ###\r\n\r\nThe `YahooProvider` is able to geocode both **IPv4 addresses** and **street addresses**.\r\nThis provider can also reverse information based on coordinates (latitude, longitude).\r\n\r\n\r\n### GoogleMapsProvider ###\r\n\r\nThe `GoogleMapsProvider` is able to geocode and reverse geocode **street addresses**.\r\n\r\n\r\n### BingMapsProvider ###\r\n\r\nThe `BingMapsProvider` is able to geocode and reverse geocode **street addresses**.\r\n\r\n\r\n### OpenStreetMapsProvider ###\r\n\r\nThe `OpenStreetMapsProvider` is able to geocode and reverse geocode **street addresses**.\r\n\r\n\r\n### CloudMadeProvider ###\r\n\r\nThe `CloudMadeProvider` is able to geocode and reverse geocode **street addresses**.\r\n\r\n\r\n### GeoipProvider ###\r\n\r\nThe `GeoipProvider` is able to geocode **IPv4 and IPv6 addresses** only. No need to use an `HttpAdapter` as it uses a local database.\r\nSee the [MaxMind page](http://www.maxmind.com/app/php) for more information.\r\n\r\n\r\n### ChainProvider ###\r\n\r\nThe `ChainProvider` is a special provider that takes a list of providers and iterates over this list to get information.\r\n\r\n\r\n### MapQuestProvider ###\r\n\r\nThe `MapQuestProvider` is able to geocode and reverse geocode **street addresses**.\r\n\r\n\r\n### OIORestProvider ###\r\n\r\nThe `OIORestProvider` is able to geocode **street addresses** only, exclusively in Denmark.\r\n\r\n\r\n### GeocoderCaProvider ###\r\n\r\nThe `GeocoderCaProvider` is able to geocode and reverse geocode **street addresses**, exclusively in USA & Canada.\r\n\r\n\r\n### GeocoderUsProvider ###\r\n\r\nThe `GeocoderUsProvider` is able to geocode **street addresses** only, exclusively in USA.\r\n\r\n\r\n### IGNOpenLSProvider ###\r\n\r\nThe `IGNOpenLSProvider` is able to geocode **street addresses** only, exclusively in France.\r\n\r\n\r\n### DataScienceToolkitProvider ###\r\n\r\nThe `DataScienceToolkitProvider` is able to geocode **IPv4 addresses** only.\r\n\r\n\r\nYou can use one of them or write your own provider. You can also register all providers and decide later.\r\nThat's we'll do:\r\n\r\n``` php\r\n<?php\r\n\r\n$geocoder = new \\Geocoder\\Geocoder();\r\n$geocoder->registerProviders(array(\r\n    new \\Geocoder\\Provider\\YahooProvider(\r\n        $adapter, '<YAHOO_API_KEY>', $locale\r\n    ),\r\n    new \\Geocoder\\Provider\\IpInfoDbProvider(\r\n        $adapter, '<IPINFODB_API_KEY>'\r\n    ),\r\n    new \\Geocoder\\Provider\\HostIpProvider($adapter)\r\n));\r\n```\r\n\r\nThe `$locale` parameter is available for the `YahooProvider`.\r\n\r\nEverything is ok, enjoy!\r\n\r\nAPI\r\n---\r\n\r\nThe main method is called `geocode()` which receives a value to geocode. It can be an IP address or a street address (partial or not).\r\n\r\n``` php\r\n<?php\r\n\r\n$result = $geocoder->geocode('88.188.221.14');\r\n// Result is:\r\n// \"latitude\"       => string(9) \"47.901428\"\r\n// \"longitude\"      => string(8) \"1.904960\"\r\n// \"bounds\"         => array(4) {\r\n//     \"south\" => string(9) \"47.813320\"\r\n//     \"west\"  => string(8) \"1.809770\"\r\n//     \"north\" => string(9) \"47.960220\"\r\n//     \"east\"  => string(8) \"1.993860\"\r\n// }\r\n// \"streetNumber\"   => string(0) \"\"\r\n// \"streetName\"     => string(0) \"\"\r\n// \"city\"           => string(7) \"Orleans\"\r\n// \"zipcode\"        => string(0) \"\"\r\n// \"county\"         => string(6) \"Loiret\"\r\n// \"region\"         => string(6) \"Centre\"\r\n// \"country\"        => string(6) \"France\"\r\n// \"timezone\"       => string(6) \"Europe/Paris\"\r\n\r\n$result = $geocoder->geocode('10 rue Gambetta, Paris, France');\r\n// Result is:\r\n// \"latitude\"       => string(9) \"48.863217\"\r\n// \"longitude\"      => string(8) \"2.388821\"\r\n// \"bounds\"         => array(4) {\r\n//     \"south\" => string(9) \"48.863217\"\r\n//     \"west\"  => string(8) \"2.388821\"\r\n//     \"north\" => string(9) \"48.863217\"\r\n//     \"east\"  => string(8) \"2.388821\"\r\n// }\r\n// \"streetNumber\"   => string(2) \"10\"\r\n// \"streetName\"     => string(15) \"Avenue Gambetta\"\r\n// \"city\"           => string(5) \"Paris\"\r\n// \"county\"         => string(5) \"Paris\"\r\n// \"zipcode\"        => string(5) \"75020\"\r\n// \"region\"         => string(14) \"Ile-de-France\"\r\n// \"country\"        => string(6) \"France\"\r\n// \"timezone\"       => string(6) \"Europe/Paris\"\r\n```\r\n\r\nThe `geocode()` method returns a `Geocoded` result object with the following API, this object also implements the `ArrayAccess` interface:\r\n\r\n* `getCoordinates()` will return an array with `latitude` and `longitude` values;\r\n* `getLatitude()` will return the `latitude` value;\r\n* `getLongitude()` will return the `longitude` value;\r\n* `getBounds()` will return an array with `south`, `west`, `north` and `east` values;\r\n* `getStreetNumber()` will return the `street number/house number` value;\r\n* `getStreetName()` will return the `street name` value;\r\n* `getCity()` will return the `city`;\r\n* `getZipcode()` will return the `zipcode`;\r\n* `getCityDistrict()` will return the `city district`, or `sublocality`;\r\n* `getCounty()` will return the `county`;\r\n* `getRegion()` will return the `region`;\r\n* `getRegionCode()` will return the `region` code (region short name);\r\n* `getCountry()` will return the `country`;\r\n* `getCountryCode()` will return the ISO country code;\r\n* `getTimezone()` will return the timezone.\r\n\r\nThe Geocoder's API is fluent, you can write:\r\n\r\n``` php\r\n<?php\r\n\r\n$result = $geocoder\r\n    ->registerProvider(new \\My\\Provider\\Custom($adapter))\r\n    ->using('custom')\r\n    ->geocode('68.145.37.34')\r\n    ;\r\n```\r\n\r\nThe `using()` method allows you to choose the `adapter` to use. When you deal with multiple adapters, you may want to\r\nchoose one of them. The default behavior is to use the first one but it can be annoying.\r\n\r\n\r\nReverse Geocoding\r\n-----------------\r\n\r\nThis library provides a `reverse()` method to retrieve information from coordinates:\r\n\r\n``` php\r\n$result = $geocoder->reverse($latitude, $longitude);\r\n```\r\n\r\n\r\nDumpers\r\n-------\r\n\r\n**Geocoder** provides dumpers that aim to transform a `ResultInterface` object in standard formats.\r\n\r\n### GPS eXchange Format (GPX) ###\r\n\r\nThe **GPS eXchange** format is designed to share geolocated data like point of interests, tracks, ways, but also\r\ncoordinates. **Geocoder** provides a dumper to convert a `ResultInterface` object in an GPX compliant format.\r\n\r\nAssuming we got a `$result` object as seen previously:\r\n\r\n``` php\r\n<?php\r\n\r\n$dumper = new \\Geocoder\\Dumper\\GpxDumper();\r\n$strGpx = $dumper->dump($result);\r\n\r\necho $strGpx;\r\n```\r\n\r\nIt will display:\r\n\r\n``` xml\r\n<gpx\r\n    version=\"1.0\"\r\n    creator=\"Geocoder\" version=\"1.0.1-dev\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns=\"http://www.topografix.com/GPX/1/0\"\r\n    xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd\">\r\n    <bounds minlat=\"2.388911\" minlon=\"48.863151\" maxlat=\"2.388911\" maxlon=\"48.863151\"/>\r\n    <wpt lat=\"48.8631507\" lon=\"2.3889114\">\r\n        <name><![CDATA[Paris]]></name>\r\n        <type><![CDATA[Address]]></type>\r\n    </wpt>\r\n</gpx>\r\n```\r\n\r\n### GeoJSON ###\r\n\r\n[GeoJSON](http://geojson.org/) is a format for encoding a variety of geographic data structures.\r\n\r\n\r\n### Keyhole Markup Language (KML) ###\r\n\r\n[Keyhole Markup Language](http://en.wikipedia.org/wiki/Keyhole_Markup_Language) is an XML notation\r\nfor expressing geographic annotation and visualization within Internet-based, two-dimensional maps\r\nand three-dimensional Earth browsers.\r\n\r\n\r\n### Well-Known Binary (WKB) ###\r\n\r\nThe Well-Known Binary (WKB) representation for geometric values is defined by the OpenGIS specification.\r\n\r\n\r\n### Well-Known Text (WKT) ###\r\n\r\nWell-known text (WKT) is a text markup language for representing vector geometry objects on a map,\r\nspatial reference systems of spatial objects and transformations between spatial reference systems.\r\n\r\n\r\nFormatter\r\n---------\r\n\r\nA common use case is to print geocoded data. Thanks to the `Formatter` class,\r\nit's really easy to format a `ResultInterface` object as a string:\r\n\r\n``` php\r\n<?php\r\n\r\n// $result is an instance of ResultInterface\r\n$formatter = new \\Geocoder\\Formatter\\Formatter($result);\r\n\r\n$formatter->format('%S %n, %z %L');\r\n// 'Badenerstrasse 120, 8001 Zuerich'\r\n\r\n$formatter->format('<p>%S %n, %z %L</p>');\r\n// '<p>Badenerstrasse 120, 8001 Zuerich</p>'\r\n```\r\n\r\nHere is the mapping:\r\n\r\n* Street Number: `%n`\r\n\r\n* Street Name: `%S`\r\n\r\n* City: `%L`\r\n\r\n* Zipcode: `%z`\r\n\r\n* County: `%P`\r\n\r\n* Region: `%R`\r\n\r\n* Region Code: `%r`\r\n\r\n* Country: `%C`\r\n\r\n* Country Code: `%c`\r\n\r\n* Timezone: `%T`\r\n\r\n\r\nExtending Things\r\n----------------\r\n\r\nYou can provide your own `adapter`, you just need to create a new class which implements `HttpAdapterInterface`.\r\n\r\nYou can also write your own `provider` by implementing the `ProviderInterface`.\r\n\r\nNote, the `AbstractProvider` class can help you by providing useful features.\r\n\r\nYou can provide your own `dumper` by implementing the `DumperInterface`.\r\n\r\nWrite your own `formatter` by implementing the `FormatterInterface`.\r\n\r\n\r\nUnit Tests\r\n----------\r\n\r\nTo run unit tests, you'll need `cURL` and a set of dependencies you can install using Composer:\r\n\r\n```\r\nphp composer.phar install --dev\r\n```\r\n\r\nOnce installed, just launch the following command:\r\n\r\n```\r\nphpunit\r\n```\r\n\r\nYou'll obtain some _skipped_ unit tests due to the need of API keys.\r\n\r\nRename the `phpunit.xml.dist` file to `phpunit.xml`, then uncomment the following lines and add your own API keys:\r\n\r\n``` xml\r\n<php>\r\n    <!-- <server name=\"IPINFODB_API_KEY\" value=\"YOUR_API_KEY\" /> -->\r\n    <!-- <server name=\"YAHOO_API_KEY\" value=\"YOUR_API_KEY\" /> -->\r\n    <!-- <server name=\"BINGMAPS_API_KEY\" value=\"YOUR_API_KEY\" /> -->\r\n    <!-- <server name=\"CLOUDMADE_API_KEY\" value=\"YOUR_API_KEY\" /> -->\r\n    <!-- <server name=\"IGN_WEB_API_KEY\" value=\"YOUR_API_KEY\" /> -->\r\n</php>\r\n```\r\n\r\nYou're done.\r\n\r\n\r\nCredits\r\n-------\r\n\r\n* William Durand <william.durand1@gmail.com>\r\n* [All contributors](https://github.com/willdurand/Geocoder/contributors)\r\n\r\n\r\nLicense\r\n-------\r\n\r\nGeocoder is released under the MIT License. See the bundled LICENSE file for details.\r\n","name":"Geocoder","google":"UA-27331396-1","tagline":"The almost missing Geocoder PHP 5.3 library"}